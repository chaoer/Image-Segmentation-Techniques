
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>L*a*b* 色空間を使った色ベースのセグメント化</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2011-11-15"><meta name="DC.source" content="ipexfabric.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style.css"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style_ja_JP.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexfabric">エディターで ipexfabric.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexfabric">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>L*a*b* 色空間を使った色ベースのセグメント化</h1><!--introduction--><p>目的は、L*a*b* 色空間を解析することで、繊維内の異なる色を識別することです。繊維イメージは、Image Acquisition Toolbox™ を使って収集されたものです。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1:イメージの取得</a></li><li><a href="#2">手順 2:各領域の L*a*b* 色空間のサンプル色の計算</a></li><li><a href="#6">手順 3:最近傍ルールを使用した各ピクセルの分類</a></li><li><a href="#10">手順 4:最近傍分類の結果の表示</a></li><li><a href="#15">手順 5:ラベルの付いた色の 'a*' および 'b*' 値の表示</a></li></ul></div><h2>手順 1:イメージの取得<a name="1"></a></h2><p><tt>fabric.png</tt> イメージを読み取ります。これはカラフルな繊維のイメージです。<tt>fabric.png</tt> を使用する代わりに、Image Acquisition Toolbox の以下の関数を使用してイメージを取得することもできます。</p><pre class="codeinput"><span class="comment">% Access a Matrox(R) frame grabber attached to a Pulnix TMC-9700 camera, and</span>
<span class="comment">% acquire data using an NTSC format.</span>
<span class="comment">% vidobj = videoinput('matrox',1,'M_NTSC_RGB');</span>

<span class="comment">% Open a live preview window.  Point camera onto a piece of colorful fabric.</span>
<span class="comment">% preview(vidobj);</span>

<span class="comment">% Capture one frame of data.</span>
<span class="comment">% fabric = getsnapshot(vidobj);</span>
<span class="comment">% imwrite(fabric,'fabric.png','png');</span>

<span class="comment">% Delete and clear associated variables.</span>
<span class="comment">% delete(vidobj)</span>
<span class="comment">% clear vidobj;</span>

fabric = imread(<span class="string">'fabric.png'</span>);
figure(1), imshow(fabric), title(<span class="string">'fabric'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_01.png" alt=""> <h2>手順 2:各領域の L*a*b* 色空間のサンプル色の計算<a name="2"></a></h2><p>イメージ内には 6 つの主な色があります。背景色は赤、緑、紫、黄、およびマゼンタです。これらの色を視覚的に簡単に区別できることに注目してください。L*a*b* 色空間 (CIELAB または CIE L*a*b*) を使用すると、このような視覚的差異を定量化できます。</p><p>L*a*b* 色空間は CIE XYZ 三刺激値から導出されます。L*a*b* 空間は、明度 'L*' または輝度レイヤー、色が赤-緑の軸に沿って低下する場所を示す色度レイヤー 'a*'、および色が青-黄の軸に沿って低下する場所を示す色度レイヤー 'b*' から構成されます。</p><p>色ごとに小さなサンプル領域を選択し、各サンプル領域の平均の色を 'a*b*' 空間で計算する方法をとります。これらの色マーカーを使用して、各ピクセルを分類します。</p><p>このデモを簡単にするために、MAT ファイルに保存される領域座標を読み込みます。</p><pre class="codeinput">load <span class="string">regioncoordinates</span>;

nColors = 6;
sample_regions = false([size(fabric,1) size(fabric,2) nColors]);

<span class="keyword">for</span> count = 1:nColors
  sample_regions(:,:,count) = roipoly(fabric,region_coordinates(:,1,count),<span class="keyword">...</span>
                                      region_coordinates(:,2,count));
<span class="keyword">end</span>

imshow(sample_regions(:,:,2)),title(<span class="string">'sample region for red'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_02.png" alt=""> <p>繊維の RGB イメージを、<tt>makecform</tt> および <tt>applycform</tt> を使用して、L*a*b* イメージに変換します。</p><pre class="codeinput">cform = makecform(<span class="string">'srgb2lab'</span>);
lab_fabric = applycform(fabric,cform);
</pre><p><tt>roipoly</tt> で抽出した領域ごとに、平均の 'a*' および 'b*' 値を計算します。これらの値は、'a*b*' 空間の色マーカーとして使用されます。</p><pre class="codeinput">a = lab_fabric(:,:,2);
b = lab_fabric(:,:,3);
color_markers = repmat(0, [nColors, 2]);

<span class="keyword">for</span> count = 1:nColors
  color_markers(count,1) = mean2(a(sample_regions(:,:,count)));
  color_markers(count,2) = mean2(b(sample_regions(:,:,count)));
<span class="keyword">end</span>
</pre><p>たとえば、'a*b*' 空間での赤のサンプル領域の平均色は以下のようになります。</p><pre class="codeinput">disp(sprintf(<span class="string">'[%0.3f,%0.3f]'</span>,color_markers(2,1),color_markers(2,2)));
</pre><pre class="codeoutput">[198.183,149.722]
</pre><h2>手順 3:最近傍ルールを使用した各ピクセルの分類<a name="6"></a></h2><p>ここでは、各色マーカーは 'a*' および 'b*' 値をもっています。<tt>lab_fabric</tt> イメージ内の各ピクセルを分類するには、ピクセルと各色マーカーの間のユークリッド距離を計算します。最短距離は、ピクセルがその色マーカーに最も厳密に一致することを意味します。たとえば、ピクセルと赤の色マーカー間の距離が最小である場合、ピクセルは赤のピクセルとラベル付されます。</p><p>色ラベル (0 = 背景、1 = 赤、2 = 緑、3 = 紫、4 = マゼンタ、5 = 黄) を含んでいる配列を作成します。</p><pre class="codeinput">color_labels = 0:nColors-1;
</pre><p>最近傍分類で使用される行列を初期化します。</p><pre class="codeinput">a = double(a);
b = double(b);
distance = repmat(0,[size(a), nColors]);
</pre><p>分類を実行します。</p><pre class="codeinput"><span class="keyword">for</span> count = 1:nColors
  distance(:,:,count) = ( (a - color_markers(count,1)).^2 + <span class="keyword">...</span>
                      (b - color_markers(count,2)).^2 ).^0.5;
<span class="keyword">end</span>

[value, label] = min(distance,[],3);
label = color_labels(label);
clear <span class="string">value</span> <span class="string">distance</span>;
</pre><h2>手順 4:最近傍分類の結果の表示<a name="10"></a></h2><p>ラベル行列には、繊維イメージの各ピクセルの色ラベルが含まれています。ラベル行列を使用して、元の繊維イメージのオブジェクトを色分けします。</p><pre class="codeinput">rgb_label = repmat(label,[1 1 3]);
segmented_images = repmat(uint8(0),[size(fabric), nColors]);

<span class="keyword">for</span> count = 1:nColors
  color = fabric;
  color(rgb_label ~= color_labels(count)) = 0;
  segmented_images(:,:,:,count) = color;
<span class="keyword">end</span>

imshow(segmented_images(:,:,:,2)), title(<span class="string">'red objects'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_03.png" alt=""> <pre class="codeinput">imshow(segmented_images(:,:,:,3)), title(<span class="string">'green objects'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_04.png" alt=""> <pre class="codeinput">imshow(segmented_images(:,:,:,4)), title(<span class="string">'purple objects'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_05.png" alt=""> <pre class="codeinput">imshow(segmented_images(:,:,:,5)), title(<span class="string">'magenta objects'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_06.png" alt=""> <pre class="codeinput">imshow(segmented_images(:,:,:,6)), title(<span class="string">'yellow objects'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_07.png" alt=""> <h2>手順 5:ラベルの付いた色の 'a*' および 'b*' 値の表示<a name="15"></a></h2><p>最近傍分類が、別の色に分類されたピクセルの 'a*' および 'b*' 値をプロットすることによって、さまざまな色の母集団を分類したことがよくわかります。表示のために、各点にその色ラベルを付けます。</p><pre class="codeinput">purple = [119/255 73/255 152/255];
plot_labels = {<span class="string">'k'</span>, <span class="string">'r'</span>, <span class="string">'g'</span>, purple, <span class="string">'m'</span>, <span class="string">'y'</span>};

figure
<span class="keyword">for</span> count = 1:nColors
  plot(a(label==count-1),b(label==count-1),<span class="string">'.'</span>,<span class="string">'MarkerEdgeColor'</span>, <span class="keyword">...</span>
       plot_labels{count}, <span class="string">'MarkerFaceColor'</span>, plot_labels{count});
  hold <span class="string">on</span>;
<span class="keyword">end</span>

title(<span class="string">'Scatterplot of the segmented pixels in ''a*b*'' space'</span>);
xlabel(<span class="string">'''a*'' values'</span>);
ylabel(<span class="string">'''b*'' values'</span>);
</pre><img vspace="5" hspace="5" src="../ipexfabric_08.png" alt=""> <p class="footer">Copyright 1993-2007 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.13</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Color-Based Segmentation Using the L*a*b* Color Space % Your goal is to identify different colors in fabric by analyzing the L*a*b* % colorspace. The fabric image was acquired using the Image Acquisition Toolbox(TM). % % Copyright 1993-2007 The MathWorks, Inc.   %% Step 1: Acquire Image % Read in the |fabric.png| image, which is an image of colorful fabric.  Instead % of using |fabric.png|, you can acquire an image using the following functions in % the Image Acquisition Toolbox.  % Access a Matrox(R) frame grabber attached to a Pulnix TMC-9700 camera, and % acquire data using an NTSC format.   % vidobj = videoinput('matrox',1,'M_NTSC_RGB');  % Open a live preview window.  Point camera onto a piece of colorful fabric. % preview(vidobj);  % Capture one frame of data. % fabric = getsnapshot(vidobj); % imwrite(fabric,'fabric.png','png');  % Delete and clear associated variables. % delete(vidobj) % clear vidobj;  fabric = imread('fabric.png'); figure(1), imshow(fabric), title('fabric');  %% Step 2: Calculate Sample Colors in L*a*b* Color Space for Each Region % You can see six major colors in the image: the background color, red, green, % purple, yellow, and magenta.  Notice how easily you can visually distinguish % these colors from one another.  The L*a*b* colorspace (also known as CIELAB or % CIE L*a*b*) enables you to quantify these visual differences. % % The L*a*b* color space is derived from the CIE XYZ tristimulus values.  The % L*a*b* space consists of a luminosity 'L*' or brightness layer, chromaticity % layer 'a*' indicating where color falls along the red-green axis, and % chromaticity layer 'b*' indicating where the color falls along the blue-yellow % axis. % % Your approach is to choose a small sample region for each color and to % calculate each sample region's average color in 'a*b*' space. You will use % these color markers to classify each pixel. % % To simplify this demo, load the region coordinates that are stored in a % MAT-file.  load regioncoordinates;  nColors = 6; sample_regions = false([size(fabric,1) size(fabric,2) nColors]);  for count = 1:nColors   sample_regions(:,:,count) = roipoly(fabric,region_coordinates(:,1,count),...                                       region_coordinates(:,2,count)); end  imshow(sample_regions(:,:,2)),title('sample region for red');  %% % Convert your fabric RGB image into an L*a*b* image using |makecform| and % |applycform|.  cform = makecform('srgb2lab'); lab_fabric = applycform(fabric,cform);  %% % Calculate the mean 'a*' and 'b*' value for each area that you extracted with % |roipoly|.  These values serve as your color markers in 'a*b*' space.  a = lab_fabric(:,:,2); b = lab_fabric(:,:,3); color_markers = repmat(0, [nColors, 2]);  for count = 1:nColors   color_markers(count,1) = mean2(a(sample_regions(:,:,count)));   color_markers(count,2) = mean2(b(sample_regions(:,:,count))); end  %% % For example, the average color of the red sample region in 'a*b*' space is  disp(sprintf('[%0.3f,%0.3f]',color_markers(2,1),color_markers(2,2)));  %% Step 3: Classify Each Pixel Using the Nearest Neighbor Rule % Each color marker now has an 'a*' and a 'b*' value.  You can classify each pixel % in the |lab_fabric| image by calculating the Euclidean distance between that % pixel and each color marker.  The smallest distance will tell you that the % pixel most closely matches that color marker.  For example, if the distance % between a pixel and the red color marker is the smallest, then the pixel would % be labeled as a red pixel.  %% % Create an array that contains your color labels, % i.e., 0 = background, 1 = red, 2 = green, 3 = purple, 4 = magenta, and 5 = yellow.  color_labels = 0:nColors-1;  %% % Initialize matrices to be used in the nearest neighbor classification.  a = double(a); b = double(b); distance = repmat(0,[size(a), nColors]);  %% % Perform classification  for count = 1:nColors   distance(:,:,count) = ( (a - color_markers(count,1)).^2 + ...                       (b - color_markers(count,2)).^2 ).^0.5; end  [value, label] = min(distance,[],3); label = color_labels(label); clear value distance;  %% Step 4: Display Results of Nearest Neighbor Classification  % The label matrix contains a color label for each pixel in the fabric % image. Use the label matrix to separate objects in the original fabric % image by color.  rgb_label = repmat(label,[1 1 3]); segmented_images = repmat(uint8(0),[size(fabric), nColors]);  for count = 1:nColors   color = fabric;   color(rgb_label ~= color_labels(count)) = 0;   segmented_images(:,:,:,count) = color; end   imshow(segmented_images(:,:,:,2)), title('red objects');  %%  imshow(segmented_images(:,:,:,3)), title('green objects');  %%  imshow(segmented_images(:,:,:,4)), title('purple objects');  %%  imshow(segmented_images(:,:,:,5)), title('magenta objects');  %%  imshow(segmented_images(:,:,:,6)), title('yellow objects');   %% Step 5: Display 'a*' and 'b*' Values of the Labeled Colors. % You can see how well the nearest neighbor classification separated the % different color populations by plotting the 'a*' and 'b*' values of pixels that % were classified into separate colors.  For display purposes, label each % point with its color label.  purple = [119/255 73/255 152/255]; plot_labels = {'k', 'r', 'g', purple, 'm', 'y'};  figure for count = 1:nColors   plot(a(label==count-1),b(label==count-1),'.','MarkerEdgeColor', ...        plot_labels{count}, 'MarkerFaceColor', plot_labels{count});   hold on; end    title('Scatterplot of the segmented pixels in ''a*b*'' space'); xlabel('''a*'' values'); ylabel('''b*'' values');   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>
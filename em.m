% em.m % Matt Rozak
% Image segmentation using Expectation-Maximization w/ a mix of Gaussians
% Heavily based off of implementation by Rongwen Lu
% http://www.mathworks.com/matlabcentral/fileexchange/34164-image-segmentation-with-em-algorithm

% %% args %%
% image   - a MxNxP grayscale or RGB color image to segment with EM (from imread)
%            M - num rows
%            N - num columns
%            P - length of property vector
% K       - the number of clusters
% maxIter - the maximum number of EM iterations 
% convTol - the tolerance of convergence

function maskOut = em(image, K, maxIter, useG, gSize, gSigma) %, maxIter, convTol)

img=double(image);

[M,N,P]=size(img);
n=M*N;
imgR=img(:,:,1); 
imgG=img(:,:,2);
imgB=img(:,:,3);
[cy,cx]=ind2sub([M,N],1:n);

% normalize each vector; delete it if normalization is not needed; weights
%  are also assigned here;
imgR=mat2gray(imgR);
imgG=mat2gray(imgG);
imgB=mat2gray(imgB);
cy=mat2gray(cy);
cx=mat2gray(cx);

% Gaussian filter - helps reduce noise when relying on color space alone
if useG ~= 0
    w=fspecial('gaussian',[gSize,gSize],gSigma);
    imgR=imfilter(imgR,w);
    imgG=imfilter(imgG,w);
    imgB=imfilter(imgB,w);
end

% assign vectors into the matrix raw
% Raw's size is [n,dim], where n is the NO of data and dim is the dimention of data.
raw=zeros(n,3);
raw(:,1)=imgR(:);
raw(:,2)=imgG(:);
raw(:,3)=imgB(:);
% raw(:,4)=cy.';  % potentially use spatial
% raw(:,5)=cx.';

% Use Expectation Maximization method to estimate K Gaussian distribution functions. 

% u is a vector of the estimated means of Gaussian function
% initialize centroid matrix u; u has K raws. NO of column is the same as raw
[n,dim]=size(raw);
u = raw(randi([1,n],K,1),:);

% v is the vector ot the estimated SD 
% initialize standard diviation v, v has K raws, one column.
v=zeros(K,1);
for ii=1:K
    raw_tmp=raw(ii:K:end,1);
    v(ii,:)=std(raw_tmp);
end

w=ones(K,1)/K; % initialize weight w

% initialize membership probability matrix (assignment matrix) p, which is p(K|x)
% Its [ii,jj]th element is the probability that Xii is generated by jjth Gaussian function.
p=zeros(n,K);

% do interation to get best r
u0=u*0;
v0=0*v;
w0=w*0;
energy=sum(sum((u-u0).^2))+sum(sum((v-v0).^2))+(sum((w-w0).^2));
iteration=1;
x_u=zeros(size(raw));
while energy>10^(-6) && iteration < maxIter

    % calculate membership probability, which is also assignment matrix
    for jj=1:K
        for ss=1:dim
            x_u(:,ss)=raw(:,ss)-u(jj,ss)*ones(n,1);
        end
        x_u=x_u.*x_u;
        p(:,jj)=power(sqrt(2*pi)*v(jj),-1*dim)*exp((-1/2)*sum(x_u,2)./(v(jj).^2));
        p(:,jj)=p(:,jj)*w(jj);
       
    end
    % normalize p on the x dimention
    pSum=sum(p,2);
    for jj=1:K
        p(:,jj)=p(:,jj)./pSum;
    end
    
    % normlaize p on the y dimention, yielding pNorm
    pSum2=sum(p,1);
    pNorm=p*0;
    for jj=1:K
        pNorm(:,jj)=p(:,jj)/pSum2(jj);
    end
    
    % save current u, v, and w as u0, v0 and w0
    u0=u;v0=v;w0=w;
    
    %update u
    u=(pNorm.')*raw;
    
    % update v
    for jj=1:K
        for ss=1:dim
            x_u(:,ss)=raw(:,ss)-u(jj,ss)*ones(n,1);
        end
        x_u=x_u.*x_u;
        x_uSum=sum(x_u,2);
        v(jj)=sqrt(1/dim*(pNorm(:,jj).')*x_uSum);
    end

    % update w
    w=(sum(p)/n).';
    
    % update and display iteration and energy
    
    %disp(sprintf(['iteration=',num2str(iteration),'; energy=',num2str(energy,'%g')]))
    iteration=iteration+1;
    energy=sum(sum((u-u0).^2))+sum(sum((v-v0).^2))+(sum((w-w0).^2));
end

imgRe=zeros(n,3);
kColor=jet(K);
kColor=u(:,1:3);
imgRe=p*kColor;

maskOut=zeros(M,N,3);
for ii=1:3
    maskOut(:,:,ii)=reshape(imgRe(:,ii),[M,N]);
end

segImg = [];

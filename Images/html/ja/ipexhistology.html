
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>K-Means クラスタリングを使った色ベースのセグメント化</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2011-11-15"><meta name="DC.source" content="ipexhistology.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style.css"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style_ja_JP.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexhistology">エディターで ipexhistology.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexhistology">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>K-Means クラスタリングを使った色ベースのセグメント化</h1><!--introduction--><p>目的は、L*a*b* 色空間と K-means クラスタリングを使って自動的に色を区分することです。</p><p>このデモは、Statistics Toolbox™ が必要です。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1:イメージの読み取り</a></li><li><a href="#2">手順 2:イメージを RGB 色空間から L*a*b* 色空間に変換</a></li><li><a href="#3">手順 3:K-Means クラスタリングを使用した 'a*b*' 空間の色の分類</a></li><li><a href="#4">手順 4:KMEANS の結果を使用したイメージの全ピクセルのラベル付け</a></li><li><a href="#5">手順 5:H&amp;E イメージを色で区分するイメージの作成</a></li><li><a href="#8">手順 6:個別イメージへの細胞核の区分</a></li></ul></div><h2>手順 1:イメージの読み取り<a name="1"></a></h2><p><tt>hestain.png</tt> を読み取ります。これはヘマトキシリンとエオシン (H&amp;E) で染色された組織のイメージです。この染色方法は、病理学者が組織の種類を区別するのに役立ちます。</p><pre class="codeinput">he = imread(<span class="string">'hestain.png'</span>);
imshow(he), title(<span class="string">'H&amp;E image'</span>);
text(size(he,2),size(he,1)+15,<span class="keyword">...</span>
     <span class="string">'Image courtesy of Alan Partin, Johns Hopkins University'</span>, <span class="keyword">...</span>
     <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="../ipexhistology_01.png" alt=""> <h2>手順 2:イメージを RGB 色空間から L*a*b* 色空間に変換<a name="2"></a></h2><p>明るさのばらつきを無視した場合に、どのくらいの色を確認できるでしょうか?白、青、ピンクの 3 つの色があります。これらの色を視覚的に簡単に区別できることに注目してください。L*a*b* 色空間 (CIELAB または CIE L*a*b*) を使用すると、このような視覚的差異を定量化できます。</p><p>L*a*b* 色空間は CIE XYZ 三刺激値から導出されます。L*a*b* 空間は、輝度レイヤー 'L*'、色が赤-緑の軸に沿って位置する場所を示す色度レイヤー 'a*'、および色が青-黄の軸に沿って位置する場所を示す色度レイヤー 'b*' から構成されます。すべての色情報は、'a*' および 'b*' レイヤーにあります。ユークリッド距離計量を使用して、2 つの色の間の距離を測定できます。</p><p><tt>makecform</tt> および <tt>applycform</tt> を使用して、イメージを L*a*b* 色空間に変換します。</p><pre class="codeinput">cform = makecform(<span class="string">'srgb2lab'</span>);
lab_he = applycform(he,cform);
</pre><h2>手順 3:K-Means クラスタリングを使用した 'a*b*' 空間の色の分類<a name="3"></a></h2><p>クラスタリングはオブジェクトのグループを区分する方法です。K-means クラスタリングは、各オブジェクトを空間配置されたオブジェクトとして取り扱います。これは、各クラスター内のオブジェクトができるだけ互いに近くにあり、他のクラスターのオブジェクトからはできるだけ遠くにある分割を探します。K-means クラスタリングでは、分割するクラスターの数と距離計量を指定し、2 つのオブジェクトが互いにどのくらい近いかを定量化する必要があります。</p><p>色情報が 'a*b*' 空間に存在するので、オブジェクトは 'a*' および 'b*' 値をもつピクセルです。<tt>kmeans</tt> を使用して、オブジェクトをユークリッド距離計量を使用する 3 つのクラスターに分類します。</p><pre class="codeinput">ab = double(lab_he(:,:,2:3));
nrows = size(ab,1);
ncols = size(ab,2);
ab = reshape(ab,nrows*ncols,2);

nColors = 3;
<span class="comment">% repeat the clustering 3 times to avoid local minima</span>
[cluster_idx cluster_center] = kmeans(ab,nColors,<span class="string">'distance'</span>,<span class="string">'sqEuclidean'</span>, <span class="keyword">...</span>
                                      <span class="string">'Replicates'</span>,3);
</pre><h2>手順 4:KMEANS の結果を使用したイメージの全ピクセルのラベル付け<a name="4"></a></h2><p>入力内のすべてのオブジェクトに対して、<tt>kmeans</tt> はクラスターに対応するインデックスを返します。<tt>kmeans</tt> からの <tt>cluster_center</tt> 出力は、デモ内で後で使用されます。イメージ内のすべてのピクセルに、その <tt>cluster_index</tt> でラベル付けします。</p><pre class="codeinput">pixel_labels = reshape(cluster_idx,nrows,ncols);
imshow(pixel_labels,[]), title(<span class="string">'image labeled by cluster index'</span>);
</pre><img vspace="5" hspace="5" src="../ipexhistology_02.png" alt=""> <h2>手順 5:H&amp;E イメージを色で区分するイメージの作成<a name="5"></a></h2><p><tt>pixel_labels</tt> を使用して、<tt>hestain.png</tt> のオブジェクトを色分けできます。この結果、3 つのイメージになります。</p><pre class="codeinput">segmented_images = cell(1,3);
rgb_label = repmat(pixel_labels,[1 1 3]);

<span class="keyword">for</span> k = 1:nColors
    color = he;
    color(rgb_label ~= k) = 0;
    segmented_images{k} = color;
<span class="keyword">end</span>

imshow(segmented_images{1}), title(<span class="string">'objects in cluster 1'</span>);
</pre><img vspace="5" hspace="5" src="../ipexhistology_03.png" alt=""> <pre class="codeinput">imshow(segmented_images{2}), title(<span class="string">'objects in cluster 2'</span>);
</pre><img vspace="5" hspace="5" src="../ipexhistology_04.png" alt=""> <pre class="codeinput">imshow(segmented_images{3}), title(<span class="string">'objects in cluster 3'</span>);
</pre><img vspace="5" hspace="5" src="../ipexhistology_05.png" alt=""> <h2>手順 6:個別イメージへの細胞核の区分<a name="8"></a></h2><p>いずれかのクラスターに、紺色と水色のオブジェクトがあることに注目してください。L*a*b* 色空間の 'L*' レイヤーを使用して、水色から紺色を分離します。細胞核は紺色です。</p><p>'L*' レイヤーには各色の輝度値が含まれていることを思い出してください。青いオブジェクトが含まれているクラスターを探します。このクラスターのピクセルの輝度値を抽出し、<tt>im2bw</tt> を使用してそれらの値をしきい値処理します。</p><p><tt>kmeans</tt> は毎回同じ <tt>cluster_idx</tt> 値を返さないため、青いオブジェクトを含むクラスターのインデックスをプログラムで決定しなければなりません。これは <tt>cluster_center</tt> 値を使用して行えます。この値は、各クラスターの平均 'a*' および 'b*' 値を含んでいます。青いクラスターには最小の cluster_center 値 (実験的に決定される) があります。</p><pre class="codeinput">mean_cluster_value = mean(cluster_center,2);
[tmp, idx] = sort(mean_cluster_value);
blue_cluster_num = idx(1);

L = lab_he(:,:,1);
blue_idx = find(pixel_labels == blue_cluster_num);
L_blue = L(blue_idx);
is_light_blue = im2bw(L_blue,graythresh(L_blue));
</pre><p>マスク <tt>is_light_blue</tt> を使用して、青い細胞核に属するピクセルにラベルを付けます。次に、別のイメージで青い細胞核を表示します。</p><pre class="codeinput">nuclei_labels = repmat(uint8(0),[nrows ncols]);
nuclei_labels(blue_idx(is_light_blue==false)) = 1;
nuclei_labels = repmat(nuclei_labels,[1 1 3]);
blue_nuclei = he;
blue_nuclei(nuclei_labels ~= 1) = 0;
imshow(blue_nuclei), title(<span class="string">'blue nuclei'</span>);
</pre><img vspace="5" hspace="5" src="../ipexhistology_06.png" alt=""> <p class="footer">Copyright 1993-2007 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.13</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Color-Based Segmentation Using K-Means Clustering % Your goal is to segment colors in an automated fashion using the L*a*b* color % space and K-means clustering. % % This demo requires Statistics Toolbox(TM).  % Copyright 1993-2007 The MathWorks, Inc.  %% Step 1: Read Image % Read in |hestain.png|, which is an image of tissue stained with hemotoxylin % and eosin (H&E). This staining method helps pathologists distinguish different % tissue types.  he = imread('hestain.png'); imshow(he), title('H&E image'); text(size(he,2),size(he,1)+15,...      'Image courtesy of Alan Partin, Johns Hopkins University', ...      'FontSize',7,'HorizontalAlignment','right');   %% Step 2: Convert Image from RGB Color Space to L*a*b* Color Space % How many colors do you see in the image if you ignore variations in % brightness?  There are three colors: white, blue, and pink.  Notice how easily % you can visually distinguish these colors from one another.  The L*a*b* color % space (also known as CIELAB or CIE L*a*b*) enables you to quantify these % visual differences. % % The L*a*b* color space is derived from the CIE XYZ tristimulus values.  The % L*a*b* space consists of a luminosity layer 'L*', chromaticity-layer 'a*' % indicating where color falls along the red-green axis, and chromaticity-layer % 'b*' indicating where the color falls along the blue-yellow axis. All of the % color information is in the 'a*' and 'b*' layers. You can measure the % difference between two colors using the Euclidean distance metric. % % Convert the image to L*a*b* color space using |makecform| and |applycform|.  cform = makecform('srgb2lab'); lab_he = applycform(he,cform);  %% Step 3: Classify the Colors in 'a*b*' Space Using K-Means Clustering % Clustering is a way to separate groups of objects.  K-means clustering treats % each object as having a location in space. It finds partitions such that % objects within each cluster are as close to each other as possible, and as far % from objects in other clusters as possible. K-means clustering requires that % you specify the number of clusters to be partitioned and a distance metric to % quantify how close two objects are to each other. % % Since the color information exists in the 'a*b*' space, your objects are % pixels with 'a*' and 'b*' values.  Use |kmeans| to cluster the objects into % three clusters using the Euclidean distance metric.  ab = double(lab_he(:,:,2:3)); nrows = size(ab,1); ncols = size(ab,2); ab = reshape(ab,nrows*ncols,2);  nColors = 3; % repeat the clustering 3 times to avoid local minima [cluster_idx cluster_center] = kmeans(ab,nColors,'distance','sqEuclidean', ...                                       'Replicates',3);  %% Step 4: Label Every Pixel in the Image Using the Results from KMEANS % For every object in your input, |kmeans| returns an index corresponding to a % cluster. The |cluster_center| output from |kmeans| will be used later in the % demo. Label every pixel in the image with its |cluster_index|.  pixel_labels = reshape(cluster_idx,nrows,ncols); imshow(pixel_labels,[]), title('image labeled by cluster index');  %% Step 5: Create Images that Segment the H&E Image by Color. % Using |pixel_labels|, you can separate objects in |hestain.png| by color, % which will result in three images.  segmented_images = cell(1,3); rgb_label = repmat(pixel_labels,[1 1 3]);  for k = 1:nColors     color = he;     color(rgb_label ~= k) = 0;     segmented_images{k} = color; end  imshow(segmented_images{1}), title('objects in cluster 1');  %%   imshow(segmented_images{2}), title('objects in cluster 2');  %%   imshow(segmented_images{3}), title('objects in cluster 3');  %% Step 6: Segment the Nuclei into a Separate Image % Notice that there are dark and light blue objects in one of the clusters. % You can separate dark blue from light blue using the 'L*' layer in the % L*a*b* color space. The cell nuclei are dark blue. % % Recall that the 'L*' layer contains the brightness values of each color. % Find the cluster that contains the blue objects. Extract the brightness % values of the pixels in this cluster and threshold them using |im2bw|. % % You must programmatically determine the index of the cluster containing % the blue objects because |kmeans| will not return the same |cluster_idx| % value every time.  You can do this using the |cluster_center| value, % which contains the mean 'a*' and 'b*' value for each cluster. The blue % cluster has the smallest cluster_center value (determined % experimentally). mean_cluster_value = mean(cluster_center,2); [tmp, idx] = sort(mean_cluster_value); blue_cluster_num = idx(1);  L = lab_he(:,:,1); blue_idx = find(pixel_labels == blue_cluster_num); L_blue = L(blue_idx); is_light_blue = im2bw(L_blue,graythresh(L_blue));  %% % Use the mask |is_light_blue| to label which pixels belong to the blue % nuclei. Then display the blue nuclei in a separate image.  nuclei_labels = repmat(uint8(0),[nrows ncols]); nuclei_labels(blue_idx(is_light_blue==false)) = 1; nuclei_labels = repmat(nuclei_labels,[1 1 3]); blue_nuclei = he; blue_nuclei(nuclei_labels ~= 1) = 0; imshow(blue_nuclei), title('blue nuclei');   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>
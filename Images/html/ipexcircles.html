
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Detect and Measure Circular Objects in an Image</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-01-17"><meta name="DC.source" content="ipexcircles.m"><link rel="stylesheet" type="text/css" href="../../../matlab/helptools/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexcircles">Open ipexcircles.m in the Editor</a></div><div class="right"><a href="matlab:echodemo ipexcircles">Run in the Command Window</a></div></div><div class="content"><h1>Detect and Measure Circular Objects in an Image</h1><!--introduction--><p>This example shows how to use <tt>imfindcircles</tt> to automatically detect circles or circular objects in an image. It also shows the use of <tt>viscircles</tt> to visualize the detected circles.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Step 1: Load Image</a></li><li><a href="#3">Step 2: Determine Radius Range for Searching Circles</a></li><li><a href="#5">Step 3: Initial Attempt to Find Circles</a></li><li><a href="#8">Step 4: Increase Detection Sensitivity</a></li><li><a href="#10">Step 5: Draw the Circles on the Image</a></li><li><a href="#13">Step 6: Use the Second Method (Two-stage) for Finding Circles</a></li><li><a href="#16">Step 7: Why are Some Circles Still Getting Missed?</a></li><li><a href="#17">Step 8: Find 'Bright' Circles in the Image</a></li><li><a href="#18">Step 9: Draw 'Bright' Circles with Different Color</a></li><li><a href="#20">Step 10: Lower the Value of 'EdgeThreshold'</a></li><li><a href="#21">Step 11: Draw 'Dark' and 'Bright' Circles Together</a></li></ul></div><h2>Step 1: Load Image<a name="1"></a></h2><p>This example uses an image of round plastic chips of various colors.</p><pre class="codeinput">rgb = imread(<span class="string">'coloredChips.png'</span>);
figure
imshow(rgb)
</pre><img vspace="5" hspace="5" src="ipexcircles_01.png" alt=""> <p>Besides having plenty of circles to detect, there are a few interesting things going on in this image from a circle detection point-of-view:</p><div><ol><li>There are chips of different colors, which have different contrasts with respect to the background. On one end, the blue and red ones have strong contrast on this background. On the other end, some of the yellow chips do not contrast well with the background.</li><li>Notice how some chips are on top of each other and some others that are close together and almost touching each other. Overlapping object boundaries and object occlusion are usually challenging scenarios for object detection.</li></ol></div><h2>Step 2: Determine Radius Range for Searching Circles<a name="3"></a></h2><p><tt>imfindcircles</tt> needs a radius range to search for the circles. A quick way to find the appropriate radius range is to use the interactive tool <tt>imdistline</tt> to get an approximate estimate of the radii of various objects.</p><pre class="codeinput">d = imdistline;
</pre><img vspace="5" hspace="5" src="ipexcircles_02.png" alt=""> <p><tt>imdistline</tt> creates a draggable tool that can be moved to fit across a chip and the numbers can be read to get an approximate estimate of its radius. Most chips have radius in the range of 21-23 pixels. Use a slightly larger radius range of 20-25 pixels just to be sure. Before that remove the <tt>imdistline</tt> tool.</p><pre class="codeinput">delete(d);
</pre><img vspace="5" hspace="5" src="ipexcircles_03.png" alt=""> <h2>Step 3: Initial Attempt to Find Circles<a name="5"></a></h2><p>Call <tt>imfindcircles</tt> on this image with the search radius of [20 25] pixels. Before that, it is a good practice to ask whether the objects are brighter or darker than the background. To answer that question, look at the grayscale version of this image.</p><pre class="codeinput">gray_image = rgb2gray(rgb);
imshow(gray_image);
</pre><img vspace="5" hspace="5" src="ipexcircles_04.png" alt=""> <p>The background is quite bright and most of the chips are darker than the background. But, by default, <tt>imfindcircles</tt> finds circular objects that are brighter than the background. So, set the parameter 'ObjectPolarity' to 'dark' in <tt>imfindcircles</tt> to search for dark circles.</p><pre class="codeinput">[centers, radii] = imfindcircles(rgb,[20 25],<span class="string">'ObjectPolarity'</span>,<span class="string">'dark'</span>)
</pre><pre class="codeoutput">
centers =

     []


radii =

     []

</pre><p>Note that the outputs <tt>centers</tt> and <tt>radii</tt> are empty, which means that no circles were found. This happens frequently because <tt>imfindcircles</tt> is a circle <i>detector</i>, and similar to most detectors, <tt>imfindcircles</tt> has an internal <i>detection threshold</i> that determines its sensitivity. In simple terms it means that the detector's confidence in a certain (circle) detection has to be greater than a certain level before it is considered a <i>valid</i> detection. <tt>imfindcircles</tt> has a parameter 'Sensitivity' which can be used to control this internal threshold, and consequently, the sensitivity of the algorithm. A higher 'Sensitivity' value sets the detection threshold lower and leads to detecting more circles. This is similar to the sensitivity control on the motion detectors used in home security systems.</p><h2>Step 4: Increase Detection Sensitivity<a name="8"></a></h2><p>Coming back to the chip image, it is possible that at the default sensitivity level all the circles are lower than the internal threshold, which is why no circles were detected. By default, 'Sensitivity', which is a number between 0 and 1, is set to 0.85. Increase 'Sensitivity' to 0.9.</p><pre class="codeinput">[centers, radii] = imfindcircles(rgb,[20 25],<span class="string">'ObjectPolarity'</span>,<span class="string">'dark'</span>, <span class="keyword">...</span>
    <span class="string">'Sensitivity'</span>,0.9)
</pre><pre class="codeoutput">
centers =

  146.1895  198.5824
  328.8132  135.5883
  130.3134   43.8039
  175.2698  297.0583
  312.2831  192.3709
  327.1316  297.0077
  243.9893  166.4538
  271.5873  280.8920


radii =

   23.1604
   22.5710
   22.9576
   23.7356
   22.9551
   22.9995
   22.9055
   23.0298

</pre><p>This time <tt>imfindcircles</tt> found some circles - eight to be precise. <tt>centers</tt> contains the locations of circle centers and <tt>radii</tt> contains the estimated radii of those circles.</p><h2>Step 5: Draw the Circles on the Image<a name="10"></a></h2><p>The function <tt>viscircles</tt> can be used to draw circles on the image. Output variables <tt>centers</tt> and <tt>radii</tt> from <tt>imfindcircles</tt> can be passed directly to <tt>viscircles</tt>.</p><pre class="codeinput">imshow(rgb);

h = viscircles(centers,radii);
</pre><img vspace="5" hspace="5" src="ipexcircles_05.png" alt=""> <p>The circle centers seem correctly positioned and their corresponding radii seem to match well to the actual chips. But still quite a few chips were missed. Try increasing the 'Sensitivity' even more, to 0.92.</p><pre class="codeinput">[centers, radii] = imfindcircles(rgb,[20 25],<span class="string">'ObjectPolarity'</span>,<span class="string">'dark'</span>, <span class="keyword">...</span>
    <span class="string">'Sensitivity'</span>,0.92);

length(centers)
</pre><pre class="codeoutput">
ans =

    16

</pre><p>So increasing 'Sensitivity' gets us even more circles. Plot these circles on the image again.</p><pre class="codeinput">delete(h);  <span class="comment">% Delete previously drawn circles</span>
h = viscircles(centers,radii);
</pre><img vspace="5" hspace="5" src="ipexcircles_06.png" alt=""> <h2>Step 6: Use the Second Method (Two-stage) for Finding Circles<a name="13"></a></h2><p>This result looks better. Now, under the hood, <tt>imfindcircles</tt> has two different methods for finding circles. So far the default method, called the <i>phase coding</i> method, was used for detecting circles. There's another method, popularly called the <i>two-stage</i> method, that is available in <tt>imfindcircles</tt>. Use the two-stage method and show the results.</p><pre class="codeinput">[centers, radii] = imfindcircles(rgb,[20 25], <span class="string">'ObjectPolarity'</span>,<span class="string">'dark'</span>, <span class="keyword">...</span>
          <span class="string">'Sensitivity'</span>,0.92,<span class="string">'Method'</span>,<span class="string">'twostage'</span>);

delete(h);

h = viscircles(centers,radii);
</pre><img vspace="5" hspace="5" src="ipexcircles_07.png" alt=""> <p>The two-stage method is detecting more circles, at the Sensitivity of 0.92. In general, these two method are complementary in that have they have different strengths. Phase coding method is typically faster and slightly more robust to noise than the two-stage method. But it may also need higher 'Sensitivity' levels to get the same number of detections as the two-stage method. For example, the phase coding method also finds the same chips if the 'Sensitivity' level is raised higher, say to 0.95.</p><pre class="codeinput">[centers, radii] = imfindcircles(rgb,[20 25], <span class="string">'ObjectPolarity'</span>,<span class="string">'dark'</span>, <span class="keyword">...</span>
          <span class="string">'Sensitivity'</span>,0.95,<span class="string">'Method'</span>,<span class="string">'twostage'</span>);

delete(h);

viscircles(centers,radii);
</pre><img vspace="5" hspace="5" src="ipexcircles_08.png" alt=""> <p>Note that both the methods in <tt>imfindcircles</tt> find the centers and radii of the partially visible (occluded) chips accurately.</p><h2>Step 7: Why are Some Circles Still Getting Missed?<a name="16"></a></h2><p>Looking at the last result, it is curious that <tt>imfindcircles</tt> does not find the yellow chips in the image. The yellow chips do not have strong contrast with the background. In fact they seem to have very similar intensities as the background. Is it possible that the yellow chips are not really 'darker' than the background as was assumed? To confirm, show the grayscale version of this image again.</p><pre class="codeinput">imshow(gray_image);
</pre><img vspace="5" hspace="5" src="ipexcircles_09.png" alt=""> <h2>Step 8: Find 'Bright' Circles in the Image<a name="17"></a></h2><p>Indeed! The yellow chips are almost the same intensity, maybe even brighter, as compared to the background. Therefore, to detect the yellow chips, change 'ObjectPolarity' to 'bright'.</p><pre class="codeinput">[centersBright, radiiBright] = imfindcircles(rgb,[20 25],<span class="string">'ObjectPolarity'</span>, <span class="keyword">...</span>
    <span class="string">'bright'</span>,<span class="string">'Sensitivity'</span>,0.92);
</pre><h2>Step 9: Draw 'Bright' Circles with Different Color<a name="18"></a></h2><p>Draw the <i>bright</i> circles in a different color, say blue, by changing the 'EdgeColor' parameter in <tt>viscircles</tt>.</p><pre class="codeinput">imshow(rgb);

hBright = viscircles(centersBright, radiiBright,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="ipexcircles_10.png" alt=""> <p>Three of the missing yellow chips were found. One yellow chip is still missing.  These yellow ones are hard to find because of they don't <i>stand out</i> as well as others on this background.</p><h2>Step 10: Lower the Value of 'EdgeThreshold'<a name="20"></a></h2><p>There is another parameter in <tt>imfindcircles</tt> which may be useful here, namely 'EdgeThreshold'. To find circles, <tt>imfindcircles</tt> uses only the edge pixels in the image. These edge pixels are essentially pixels with high gradient value. The 'EdgeThreshold' parameter controls how <i>high</i> the gradient value at a pixel has to be before it is considered an edge pixel and included in computation. A high value (closer to 1) for this parameter will allow only the strong edges (higher gradient values) to be included, whereas a low value (closer to 0) is more permissive and includes even the weaker edges (lower gradient values) in computation. In case of the missing yellow chip, since the contrast is low, some of the boundary pixels (on the circumference of the chip) are expected to have low gradient values. Therefore, lower the 'EdgeThreshold' parameter to ensure that the most of the edge pixels for the yellow chip are included in computation.</p><pre class="codeinput">[centersBright, radiiBright, metricBright] = imfindcircles(rgb,[20 25], <span class="keyword">...</span>
    <span class="string">'ObjectPolarity'</span>,<span class="string">'bright'</span>,<span class="string">'Sensitivity'</span>,0.92,<span class="string">'EdgeThreshold'</span>,0.1);

delete(hBright);

hBright = viscircles(centersBright, radiiBright,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="ipexcircles_11.png" alt=""> <h2>Step 11: Draw 'Dark' and 'Bright' Circles Together<a name="21"></a></h2><p>Now <tt>imfindcircles</tt> finds all of the yellow ones, and a green one too. Draw these chips in blue, together with the other chips that were found earlier (with 'ObjectPolarity' set to 'dark'), in red.</p><pre class="codeinput">h = viscircles(centers,radii);
</pre><img vspace="5" hspace="5" src="ipexcircles_12.png" alt=""> <p>All the circles are detected. A final word - it should be noted that changing the parameters to be more aggressive in detection may find more circles, but it also increases the likelihood of detecting false circles. There is a trade-off between the number of true circles that can be found (detection rate) and the number of false circles that are found with them (false alarm rate).</p><p>Happy circle hunting!</p><p class="footer">Copyright 2012 The MathWorks, Inc.<br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br><br>
		  MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.
      </p></div><!--
##### SOURCE BEGIN #####
%% Detect and Measure Circular Objects in an Image
% This example shows how to use |imfindcircles| to automatically detect
% circles or circular objects in an image. It also shows the use of
% |viscircles| to visualize the detected circles.

% Copyright 2012 The MathWorks, Inc.

%% Step 1: Load Image
% This example uses an image of round plastic chips of various colors.

rgb = imread('coloredChips.png');
figure
imshow(rgb)

%% 
% Besides having plenty of circles to detect, there are a few interesting
% things going on in this image from a circle detection point-of-view:
% 
% # There are chips of different colors, which have different contrasts
% with respect to the background. On one end, the blue and red ones have
% strong contrast on this background. On the other end, some of the yellow
% chips do not contrast well with the background.
% # Notice how some chips are on top of each other and some others that are
% close together and almost touching each other. Overlapping object
% boundaries and object occlusion are usually challenging scenarios for
% object detection.

%% Step 2: Determine Radius Range for Searching Circles
% |imfindcircles| needs a radius range to search for the circles. A quick
% way to find the appropriate radius range is to use the interactive tool
% |imdistline| to get an approximate estimate of the radii of various
% objects.
d = imdistline;


%% 
% |imdistline| creates a draggable tool that can be moved to fit across a
% chip and the numbers can be read to get an approximate estimate of its
% radius. Most chips have radius in the range of 21-23 pixels. Use a
% slightly larger radius range of 20-25 pixels just to be sure. Before that
% remove the |imdistline| tool.
delete(d);

%% Step 3: Initial Attempt to Find Circles
% Call |imfindcircles| on this image with the search radius of [20 25]
% pixels. Before that, it is a good practice to ask whether the objects are
% brighter or darker than the background. To answer that question, look at
% the grayscale version of this image.

gray_image = rgb2gray(rgb);
imshow(gray_image);

%%
% The background is quite bright and most of the chips are darker than the
% background. But, by default, |imfindcircles| finds circular objects that
% are brighter than the background. So, set the parameter 'ObjectPolarity'
% to 'dark' in |imfindcircles| to search for dark circles.

[centers, radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark')

%% 
% Note that the outputs |centers| and |radii| are empty, which means that
% no circles were found. This happens frequently because |imfindcircles| is
% a circle _detector_, and similar to most detectors, |imfindcircles| has
% an internal _detection threshold_ that determines its sensitivity. In
% simple terms it means that the detector's confidence in a certain
% (circle) detection has to be greater than a certain level before it is
% considered a _valid_ detection. |imfindcircles| has a parameter
% 'Sensitivity' which can be used to control this internal threshold, and
% consequently, the sensitivity of the algorithm. A higher 'Sensitivity'
% value sets the detection threshold lower and leads to detecting more
% circles. This is similar to the sensitivity control on the motion
% detectors used in home security systems.

%% Step 4: Increase Detection Sensitivity
% Coming back to the chip image, it is possible that at the default
% sensitivity level all the circles are lower than the internal threshold,
% which is why no circles were detected. By default, 'Sensitivity', which
% is a number between 0 and 1, is set to 0.85. Increase 'Sensitivity' to
% 0.9.

[centers, radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...
    'Sensitivity',0.9)

%% 
% This time |imfindcircles| found some circles - eight to be precise.
% |centers| contains the locations of circle centers and |radii| contains
% the estimated radii of those circles.
 
%% Step 5: Draw the Circles on the Image
% The function |viscircles| can be used to draw circles on the image.
% Output variables |centers| and |radii| from |imfindcircles| can be passed
% directly to |viscircles|.

imshow(rgb);

h = viscircles(centers,radii);

%% 
% The circle centers seem correctly positioned and their corresponding
% radii seem to match well to the actual chips. But still quite a few
% chips were missed. Try increasing the 'Sensitivity' even more, to 0.92.

[centers, radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...
    'Sensitivity',0.92);

length(centers)

%%
% So increasing 'Sensitivity' gets us even more circles. Plot these circles
% on the image again.

delete(h);  % Delete previously drawn circles
h = viscircles(centers,radii);

%% Step 6: Use the Second Method (Two-stage) for Finding Circles
% This result looks better. Now, under the hood, |imfindcircles| has two
% different methods for finding circles. So far the default method, called
% the _phase coding_ method, was used for detecting circles. There's
% another method, popularly called the _two-stage_ method, that is
% available in |imfindcircles|. Use the two-stage method and show the
% results.

[centers, radii] = imfindcircles(rgb,[20 25], 'ObjectPolarity','dark', ...
          'Sensitivity',0.92,'Method','twostage');

delete(h);

h = viscircles(centers,radii);

%%
% The two-stage method is detecting more circles, at the Sensitivity of
% 0.92. In general, these two method are complementary in that have they
% have different strengths. Phase coding method is typically faster and
% slightly more robust to noise than the two-stage method. But it may also
% need higher 'Sensitivity' levels to get the same number of detections as
% the two-stage method. For example, the phase coding method also finds the
% same chips if the 'Sensitivity' level is raised higher, say to 0.95.

[centers, radii] = imfindcircles(rgb,[20 25], 'ObjectPolarity','dark', ...
          'Sensitivity',0.95,'Method','twostage');

delete(h);

viscircles(centers,radii);

%%
% Note that both the methods in |imfindcircles| find the centers and radii
% of the partially visible (occluded) chips accurately.
 
%% Step 7: Why are Some Circles Still Getting Missed?
% Looking at the last result, it is curious that |imfindcircles| does not
% find the yellow chips in the image. The yellow chips do not have
% strong contrast with the background. In fact they seem to have very
% similar intensities as the background. Is it possible that the yellow
% chips are not really 'darker' than the background as was assumed? To
% confirm, show the grayscale version of this image again.

imshow(gray_image);

%% Step 8: Find 'Bright' Circles in the Image
% Indeed! The yellow chips are almost the same intensity, maybe even
% brighter, as compared to the background. Therefore, to detect the yellow
% chips, change 'ObjectPolarity' to 'bright'.

[centersBright, radiiBright] = imfindcircles(rgb,[20 25],'ObjectPolarity', ...
    'bright','Sensitivity',0.92);

%% Step 9: Draw 'Bright' Circles with Different Color
% Draw the _bright_ circles in a different color, say blue, by changing the
% 'EdgeColor' parameter in |viscircles|.

imshow(rgb); 

hBright = viscircles(centersBright, radiiBright,'EdgeColor','b');

%%
% Three of the missing yellow chips were found. One yellow chip is still
% missing.  These yellow ones are hard to find because of they don't
% _stand out_ as well as others on this background.

%% Step 10: Lower the Value of 'EdgeThreshold' 
% There is another parameter in |imfindcircles| which may be useful here,
% namely 'EdgeThreshold'. To find circles, |imfindcircles| uses only the
% edge pixels in the image. These edge pixels are essentially pixels with
% high gradient value. The 'EdgeThreshold' parameter controls how _high_
% the gradient value at a pixel has to be before it is considered an edge
% pixel and included in computation. A high value (closer to 1) for this
% parameter will allow only the strong edges (higher gradient values) to be
% included, whereas a low value (closer to 0) is more permissive and
% includes even the weaker edges (lower gradient values) in computation. In
% case of the missing yellow chip, since the contrast is low, some of the
% boundary pixels (on the circumference of the chip) are expected to have
% low gradient values. Therefore, lower the 'EdgeThreshold' parameter to
% ensure that the most of the edge pixels for the yellow chip are included
% in computation.

[centersBright, radiiBright, metricBright] = imfindcircles(rgb,[20 25], ...
    'ObjectPolarity','bright','Sensitivity',0.92,'EdgeThreshold',0.1);

delete(hBright);

hBright = viscircles(centersBright, radiiBright,'EdgeColor','b');

%% Step 11: Draw 'Dark' and 'Bright' Circles Together
% Now |imfindcircles| finds all of the yellow ones, and a green one too.
% Draw these chips in blue, together with the other chips that were found
% earlier (with 'ObjectPolarity' set to 'dark'), in red.

h = viscircles(centers,radii);

%%
% All the circles are detected. A final word - it should be noted that
% changing the parameters to be more aggressive in detection may find more
% circles, but it also increases the likelihood of detecting false circles.
% There is a trade-off between the number of true circles that can be found
% (detection rate) and the number of false circles that are found with them
% (false alarm rate).
% 
% Happy circle hunting!

displayEndOfDemoMessage(mfilename)















##### SOURCE END #####
--></body></html>
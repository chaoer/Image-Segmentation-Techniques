
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>多様な MRI イメージのレジストレーション</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-01-04"><meta name="DC.source" content="ipexknee.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style.css"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style_ja_JP.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexknee">エディターで ipexknee.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexknee">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>多様な MRI イメージのレジストレーション</h1><!--introduction--><p>この例では、<tt>imregister</tt> を使用して、強度ベースのイメージ レジストレーションにより 2 つの MRI (磁気共鳴画像) を一般的な座標系に自動的に整列させる方法を示します。他の手法とは異なり、特徴を検索したり、コントロール ポイントを使用したりしません。多くの場合、強度ベースのレジストレーションは医療やリモート センシング イメージでの使用に適しています。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: イメージの読み込み</a></li><li><a href="#4">手順 2: 初期レジストレーションの設定</a></li><li><a href="#6">手順 3: レジストレーションの改善</a></li><li><a href="#9">手順 4: レジストレーション速度の改善</a></li><li><a href="#13">手順 5: 追加の改善策</a></li><li><a href="#14">手順 6: 妥当な改善程度の決定</a></li><li><a href="#15">手順 7: 別の可視化手法</a></li></ul></div><h2>手順 1: イメージの読み込み<a name="1"></a></h2><p>この例では、膝の 2 枚の MRI (磁気共鳴) 画像を使用します。固定イメージはスピン エコー イメージであり、移動イメージは反転回復を行ったスピン エコー イメージです。同時に 2 枚の矢状スライスが取得されますが、ややずれています。</p><pre class="codeinput">fixed = dicomread(<span class="string">'knee1.dcm'</span>);
moving = dicomread(<span class="string">'knee2.dcm'</span>);
</pre><p>関数 <tt>imshowpair</tt> は、レジストレーション プロセスのどの部分でもイメージの可視化に役立つ関数です。この関数を使用し、2 枚のイメージをモンタージュ形式でそれぞれ表示したり、これらを重ねてレジストレーションの誤差の程度を示したりしてください。</p><pre class="codeinput">figure, imshowpair(moving, fixed, <span class="string">'montage'</span>)
title(<span class="string">'Unregistered'</span>)
</pre><img vspace="5" hspace="5" src="../ipexknee_01.png" alt=""> <p><tt>imshowpair</tt> で重ね合わせたイメージで、灰色の領域は同じ強度の領域に対応し、マゼンタおよび緑色の領域は片方のイメージが他方のイメージよりも明るい部分を示します。イメージの組によっては、緑色およびマゼンタの領域にレジストレーションの誤差が示されない場合もありますが、この例では色の情報を使用してレジストレーションの誤差が示される箇所を簡単に表示できます。</p><pre class="codeinput">figure, imshowpair(moving, fixed)
title(<span class="string">'Unregistered'</span>)
</pre><img vspace="5" hspace="5" src="../ipexknee_02.png" alt=""> <h2>手順 2: 初期レジストレーションの設定<a name="4"></a></h2><p>関数 <tt>imregconfig</tt> を使用すると、<tt>imregister</tt> での使用に適したオプティマイザーおよびメトリックの設定を簡単に選択できます。これら 2 つのイメージは異なる強度の分布をもつため、多様な構成を提案します。</p><pre class="codeinput">[optimizer,metric] = imregconfig(<span class="string">'multimodal'</span>);
</pre><p>また、2 つのイメージ間の歪みは、スケーリング、回転、(場合によっては) せん断などによるものです。イメージのレジストレーションにはアフィン変換を使用してください。</p><p>非常にまれに、<tt>imregister</tt> によって既定の設定でイメージが完全に整列することもありますが、既定の設定を使用すると最初に調整するプロパティを特定できるため便利です。</p><pre class="codeinput">tic
movingRegisteredDefault = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
timeDefault = toc

figure, imshowpair(movingRegisteredDefault, fixed)
title(<span class="string">'A: Default registration'</span>)
</pre><pre class="codeoutput">
timeDefault =

   13.3457

</pre><img vspace="5" hspace="5" src="../ipexknee_03.png" alt=""> <h2>手順 3: レジストレーションの改善<a name="6"></a></h2><p>初期レジストレーションはうまくいきましたが、それでも整列していない領域が一部にあります。イメージの左右の端に沿って、および右側部分の小さな明るい帯内で簡単に確認できます。オプティマイザーおよびメトリックの設定プロパティを調整し、レジストレーションを改善してください。</p><p>オプティマイザーおよびメトリックの変数は、そのプロパティによってレジストレーションを制御するオブジェクトです。</p><pre class="codeinput">optimizer
metric
</pre><pre class="codeoutput">
optimizer = 

  registration.optimizer.OnePlusOneEvolutionary

  Properties:
         GrowthFactor: 1.050000e+00
              Epsilon: 1.500000e-06
        InitialRadius: 6.250000e-03
    MaximumIterations: 100

metric = 

  registration.metric.MattesMutualInformation

  Properties:
    NumberOfSpatialSamples: 500
     NumberOfHistogramBins: 50
              UseAllPixels: 1
</pre><p>レジストレーションは既定のパラメーターを使用して改善されているため、最適化を長く実行すればさらに改善されます。</p><pre class="codeinput">optimizer.MaximumIterations = 300;

movingRegistered = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
figure, imshowpair(movingRegistered, fixed)
title(<span class="string">'MaximumIterations = 300'</span>)
</pre><img vspace="5" hspace="5" src="../ipexknee_04.png" alt=""> <p>さらに長く実行した場合、改善され続けるでしょうか。</p><pre class="codeinput">optimizer.MaximumIterations = 500;

tic
movingRegistered500 = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
time500 = toc

figure, imshowpair(movingRegistered500, fixed)
title(<span class="string">'B: MaximumIterations = 500'</span>)
</pre><pre class="codeoutput">
time500 =

   65.5255

</pre><img vspace="5" hspace="5" src="../ipexknee_05.png" alt=""> <h2>手順 4: レジストレーション速度の改善<a name="9"></a></h2><p>前の節では、既定のパラメーターを使用し実行時間を長くするだけでレジストレーションの改善が可能であることを示しました。'MaximumIterations' を増加させると収束しやすくなりますが、長時間実行すると結果が損なわれることもよくあります。</p><p>初期段階でオプティマイザーをよりアグレッシブにすることもできます。ステップ サイズを制御するパラメーターを変更すると、レジストレーションが正しい解に早く近づく場合がありますが、最適解が最適化空間の別の場所にあると極値を最適解として処理することがあります。</p><p>'InitialRadius' プロパティは、オプティマイザーの初期検索範囲を制御します。</p><pre class="codeinput">optimizer.MaximumIterations = 100;
optimizer.InitialRadius = 0.009;

movingRegistered = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
figure, imshowpair(movingRegistered, fixed)
title(<span class="string">'MaximumIterations = 100, InitialRadius = 0.009'</span>)
</pre><img vspace="5" hspace="5" src="../ipexknee_06.png" alt=""> <p>既定の設定と比較すると、結果は悪くなっています。'InitialRadius' が検索範囲の上限を指定し、'Epsilon' が下限を設定します。</p><pre class="codeinput">[optimizer,metric] = imregconfig(<span class="string">'multimodal'</span>);
optimizer.Epsilon = 1.5e-4;

movingRegistered = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
figure, imshowpair(movingRegistered, fixed)
title(<span class="string">'MaximumIterations = 100, Epsilon = 1.5e-4'</span>)
</pre><img vspace="5" hspace="5" src="../ipexknee_07.png" alt=""> <p>この設定では、既定のパラメーターとほぼ同じレジストレーションになります。性能にほとんど違いはありません。</p><p>個別に調整するオプティマイザーのプロパティに 'GrowthFactor' がまだ残っています。これは、パラメーター空間の検索範囲を広げる速度を制御します。成長係数が大きいとさらにアグレッシブな最適化が行われます。</p><pre class="codeinput">[optimizer,metric] = imregconfig(<span class="string">'multimodal'</span>);
optimizer.GrowthFactor = 1.1;

movingRegistered = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
figure, imshowpair(movingRegistered, fixed)
title(<span class="string">'MaximumIterations = 100, GrowthFactor = 1.1'</span>)
</pre><img vspace="5" hspace="5" src="../ipexknee_08.png" alt=""> <p>それではアグレッシブすぎます。既定の設定が大きすぎるかもしれません。'GrowthFactor' の設定値を小さくしてみてください。 </p><pre class="codeinput">optimizer.GrowthFactor = 1.01;

tic
movingRegisteredGrowth = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
timeGrowth = toc

figure, imshowpair(movingRegisteredGrowth, fixed)
title(<span class="string">'C: MaximumIterations = 100, GrowthFactor = 1.01'</span>)
</pre><pre class="codeoutput">
timeGrowth =

   12.1416

</pre><img vspace="5" hspace="5" src="../ipexknee_09.png" alt=""> <h2>手順 5: 追加の改善策<a name="13"></a></h2><p>通常、ステップサイズ パラメーターの値と実行する反復回数を何度も変更して組み合わせることで、最適な結果が得られます。</p><pre class="codeinput">[optimizer,metric] = imregconfig(<span class="string">'multimodal'</span>);
optimizer.GrowthFactor = 1.01;
optimizer.InitialRadius = 0.009;
optimizer.Epsilon = 1.5e-4;
optimizer.MaximumIterations = 300;

tic
movingRegisteredTuned = imregister(moving, fixed, <span class="string">'affine'</span>, optimizer, metric);
timeTuned = toc

figure, imshowpair(movingRegisteredTuned, fixed)
title(<span class="string">'D: MaximumIterations = 300, GrowthFactor = 1.01, Epsilon = 1.5e-4, InitialRadius = 0.009'</span>)
</pre><pre class="codeoutput">
timeTuned =

   36.0186

</pre><img vspace="5" hspace="5" src="../ipexknee_10.png" alt=""> <h2>手順 6: 妥当な改善程度の決定<a name="14"></a></h2><p><tt>imregister</tt> の実行結果を別の設定と比較すると、性能と精度との間にトレードオフがあることは明らかです。既定のレジストレーションを 100 回反復した場合 (A) と最も高度に調整されたプロパティのセット (B) との実行時間および品質の差は、かなり大きなものです。</p><p>標準外の成長係数を使用して <tt>imregister</tt> を 100 回反復した結果 (C) と最適な結果 (B) との差も明らかです。結果を得るまでの時間が比較的短くても、高度に調整されたレジストレーションを 300 回反復した (D) は、既定のレジストレーションを 500 回反復した (B) との品質のトレードオフが大きくなっています。</p><pre class="codeinput">figure
imshowpair(movingRegisteredDefault, fixed)
title(sprintf(<span class="string">'A - Default settings - %0.2f sec'</span>, timeDefault))

figure
imshowpair(movingRegistered500, fixed)
title(sprintf(<span class="string">'B - Default settings, 500 iterations - %0.2f sec'</span>, time500))

figure
imshowpair(movingRegisteredGrowth, fixed)
title(sprintf(<span class="string">'C - Growth factor, 100 iterations - %0.2f sec'</span>, timeGrowth))

figure
imshowpair(movingRegisteredTuned, fixed)
title(sprintf(<span class="string">'D - Highly tuned, 300 iterations - %0.2f sec'</span>, timeTuned))
</pre><img vspace="5" hspace="5" src="../ipexknee_11.png" alt=""> <img vspace="5" hspace="5" src="../ipexknee_12.png" alt=""> <img vspace="5" hspace="5" src="../ipexknee_13.png" alt=""> <img vspace="5" hspace="5" src="../ipexknee_14.png" alt=""> <h2>手順 7: 別の可視化手法<a name="15"></a></h2><p>多様なレジストレーションの品質が改善されると、レジストレーションの品質を視覚的に判断することはさらに難しくなることがよくあります。これは、強度の差が原因で不整合の領域が不明瞭になる場合があるためです。<tt>imshowpair</tt> を別の表示モードに切り替えると、表示されていなかった詳細情報が明らかになることもあります。(そうでない場合もあります)。</p><p class="footer">Copyright 2011 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.14<br><br>
		  MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.
      </p></div><!-- ##### SOURCE BEGIN ##### %% Registering Multimodal MRI Images % This example shows how you can use |imregister| to automatically % align two magnetic resonance images (MRI) to a common coordinate % system using intensity-based image registration.  Unlike some other % techniques, it does not find features or use control points. % Intensity-based registration is often well-suited for medical and % remotely sensed imagery.  % Copyright 2011 The MathWorks, Inc.   %% Step 1: Load Images % This example uses two magnetic resonance (MRI) images of a knee. % The fixed image is a spin echo image, while the moving image is a % spin echo image with inversion recovery.  The two sagittal slices % were acquired at the same time but are slightly out of alignment.  fixed = dicomread('knee1.dcm'); moving = dicomread('knee2.dcm');  %% % The |imshowpair| function is a useful function for visualizing % images during every part of the registration process.  Use it to see % the two images individually in a montage fashion or display them % stacked to show the amount of misregistration.  figure, imshowpair(moving, fixed, 'montage') title('Unregistered')  %% % In the overlapping image from |imshowpair|, gray areas correspond to % areas that have similar intensities, while magenta and green areas % show places where one image is brighter than the other.  In some % imager pairs, green and magenta areas don't always indicate % misregistration, but in this example it's easy to use the color % information to see where they do.  figure, imshowpair(moving, fixed) title('Unregistered')   %% Step 2: Set up the Initial Registration % The |imregconfig| function makes it easy to pick the correct % optimizer and metric configuration to use with |imregister|. These % two images have different intensity distributions, which suggests a % multimodal configuration.  [optimizer,metric] = imregconfig('multimodal');  %% % The distortion between the two images includes scaling, rotation, % and (possibly) shear.  Use an affine transformation to register the % images. % % It's very, very rare that |imregister| will align images perfectly % with the default settings.  Nevertheless, using them is a useful way % to decide which properties to tune first.  tic movingRegisteredDefault = imregister(moving, fixed, 'affine', optimizer, metric); timeDefault = toc  figure, imshowpair(movingRegisteredDefault, fixed) title('A: Default registration')   %% Step 3: Improve the Registration % The initial registration was pretty good, but there are still some % areas that don't line up.  It's easiest to see this along the left % and right edges of the image and in the small bright bands that run % through the right-hand part.  Try to improve the registration by % adjusting the optimizer and metric configuration properties. % % The optimizer and metric variables are objects whose properties % control the registration.  optimizer metric  %% % Because the registration improved with the default parameters, % perhaps it will continue to improve if the optimization runs longer.  optimizer.MaximumIterations = 300;  movingRegistered = imregister(moving, fixed, 'affine', optimizer, metric); figure, imshowpair(movingRegistered, fixed) title('MaximumIterations = 300')  %% % Does it continue to improve if run even longer?  optimizer.MaximumIterations = 500;  tic movingRegistered500 = imregister(moving, fixed, 'affine', optimizer, metric); time500 = toc  figure, imshowpair(movingRegistered500, fixed) title('B: MaximumIterations = 500')   %% Step 4: Improve the Speed of Registration % The previous section showed that it's often possible to improve a % registration with the default parameters simply by letting it run % longer.  Although increasing 'MaximumIterations' will likely lead to % convergence, it's also likely that running for a longer time will % yield diminishing returns. % % It's often possible to force the optimizer to be more aggressive in % its initial steps.  Changing parameters that control step size might % move the registration closer to the correct solution more quickly, % but it could result in treating a local extrema as the best answer, % when the best answer is elsewhere in the optimization space. % % The 'InitialRadius' property controls the initial search radius for % the optimizer.  optimizer.MaximumIterations = 100; optimizer.InitialRadius = 0.009;  movingRegistered = imregister(moving, fixed, 'affine', optimizer, metric); figure, imshowpair(movingRegistered, fixed) title('MaximumIterations = 100, InitialRadius = 0.009')  %% % Compared with the default configuration, the results are worse. % While 'InitialRadius specifies the upper bound of the search radius, % 'Epsilon' sets the lower bound.  [optimizer,metric] = imregconfig('multimodal'); optimizer.Epsilon = 1.5e-4;  movingRegistered = imregister(moving, fixed, 'affine', optimizer, metric); figure, imshowpair(movingRegistered, fixed) title('MaximumIterations = 100, Epsilon = 1.5e-4')  %% % This configuration yields almost exactly the same registration as % the default parameters with almost no difference in performance. % % The only remaining optimizer property to tweak independently is % 'GrowthFactor', which controls the rate at which the search radius % grows in parameter space.  A larger growth factor causes a more % aggressive optimization.  [optimizer,metric] = imregconfig('multimodal'); optimizer.GrowthFactor = 1.1;  movingRegistered = imregister(moving, fixed, 'affine', optimizer, metric); figure, imshowpair(movingRegistered, fixed) title('MaximumIterations = 100, GrowthFactor = 1.1')  %% % That seemed too aggressive.  Perhaps the default value is too % large.  Try a smaller 'GrowthFactor' setting.  optimizer.GrowthFactor = 1.01;  tic movingRegisteredGrowth = imregister(moving, fixed, 'affine', optimizer, metric); timeGrowth = toc  figure, imshowpair(movingRegisteredGrowth, fixed) title('C: MaximumIterations = 100, GrowthFactor = 1.01')   %% Step 5: Further Refinement % Usually a combination of changes to the step-size parameters and % number of iterations to run yields the best results.  [optimizer,metric] = imregconfig('multimodal'); optimizer.GrowthFactor = 1.01; optimizer.InitialRadius = 0.009; optimizer.Epsilon = 1.5e-4; optimizer.MaximumIterations = 300;  tic movingRegisteredTuned = imregister(moving, fixed, 'affine', optimizer, metric); timeTuned = toc  figure, imshowpair(movingRegisteredTuned, fixed) title('D: MaximumIterations = 300, GrowthFactor = 1.01, Epsilon = 1.5e-4, InitialRadius = 0.009')   %% Step 6: Deciding When Enough is Enough % Comparing the results of running |imregister| with different % configurations, it becomes apparent that there's a trade-off between % performance and accuracy.  The difference in execution time and % quality of the default registration run for 100 iterations (A) and % the most highly tuned set of properties (B) is quite large. % % The difference between running |imregister| with a nonstandard % growth factor for 100 iterations (C) and the best result (B) is % obvious, too. It becomes more of a trade-off between the quality of % the highly tuned registration executed to 300 iterations (D) and the % default registration run to 500 iterations (B), given the % comparatively small amount of time that it took to get there.  figure imshowpair(movingRegisteredDefault, fixed) title(sprintf('A - Default settings - %0.2f sec', timeDefault))  figure imshowpair(movingRegistered500, fixed) title(sprintf('B - Default settings, 500 iterations - %0.2f sec', time500))  figure imshowpair(movingRegisteredGrowth, fixed) title(sprintf('C - Growth factor, 100 iterations - %0.2f sec', timeGrowth))  figure imshowpair(movingRegisteredTuned, fixed) title(sprintf('D - Highly tuned, 300 iterations - %0.2f sec', timeTuned))   %% Step 7: Alternate Visualizations % Often as the quality of multimodal registrations improve it becomes more % difficult to judge the quality of registration visually.  This is because % the intensity differences can obscure areas of misalignment.  Sometimes % switching to a different display mode for |imshowpair| exposes hidden % details.  (This is not always the case.)   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>
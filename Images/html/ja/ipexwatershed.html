
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>マーカー コントロール付き watershed セグメント化</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2011-11-15"><meta name="DC.source" content="ipexwatershed.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style.css"><link rel="stylesheet" type="text/css" href="../../../../matlab/helptools/private/style_ja_JP.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexwatershed">エディターで ipexwatershed.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexwatershed">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>マーカー コントロール付き watershed セグメント化</h1><!--introduction--><p>1 つのイメージ内で接触している複数のオブジェクトを分離することは、とても難しい画像処理操作の 1 つです。Watershed 変換は、この問題によく適用されます。Watershed 変換は、明るいピクセルを高い表面、暗いピクセルを低い表面として扱うことにより、イメージ内の &quot;集水域 (catchment basins)&quot; と &quot;流域の稜線 (watershed ridge lines)&quot; を検出します。</p><p>前面のオブジェクトと背景の位置を識別、あるいは &quot;印付け&quot; することができる場合、Watershed 変換を使ったセグメント化はうまく機能します。マーカーをコントロールした watershed セグメント化は、以下の手順になります。</p><p>1. セグメント化関数を計算します。これは、暗い領域を区分しようとするオブジェクトのイメージです。</p><p>2. 前景のマーカーを計算します。これらは、各オブジェクト内のピクセルの連結された粒子です。</p><p>3. 背景のマーカーを計算します。これらは、任意のオブジェクトの一部ではないピクセルです。</p><p>4. 前景と背景のマーカーの位置が最小となるようにセグメント化関数を修正します。</p><p>5. 修正したセグメント化関数の Watershed 変換を計算します。</p><p><tt>fspecial</tt>、<tt>imfilter</tt>、<tt>watershed</tt>、<tt>label2rgb</tt>、<tt>imopen</tt>、<tt>imclose</tt>、<tt>imreconstruct</tt>、<tt>imcomplement</tt>、<tt>imregionalmax</tt>、<tt>bwareaopen</tt>、<tt>graythresh</tt>、および <tt>imimposemin</tt> などを含む数種の Image Processing Toolbox™ の関数が使用されています。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: カラー イメージの読み取りとグレースケールへの変換</a></li><li><a href="#2">手順 2: 勾配振幅をセグメント化関数として使用</a></li><li><a href="#5">手順 3: 前景オブジェクトのマーク付け</a></li><li><a href="#14">手順 4: 背景マーカーの計算</a></li><li><a href="#16">手順 5: セグメント化関数の Watershed 変換の計算</a></li><li><a href="#18">手順 6: 結果の可視化</a></li></ul></div><h2>手順 1: カラー イメージの読み取りとグレースケールへの変換<a name="1"></a></h2><pre class="codeinput">rgb = imread(<span class="string">'pears.png'</span>);
I = rgb2gray(rgb);
imshow(I)

text(732,501,<span class="string">'Image courtesy of Corel(R)'</span>,<span class="keyword">...</span>
     <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_01.png" alt=""> <h2>手順 2: 勾配振幅をセグメント化関数として使用<a name="2"></a></h2><p>ソーベル エッジ マスク <tt>imfilter</tt> および簡単な算術を使用して、勾配振幅を計算します。勾配はオブジェクトの境界線で高く、オブジェクトの内部で低くなります (ほとんどの場合)。</p><pre class="codeinput">hy = fspecial(<span class="string">'sobel'</span>);
hx = hy';
Iy = imfilter(double(I), hy, <span class="string">'replicate'</span>);
Ix = imfilter(double(I), hx, <span class="string">'replicate'</span>);
gradmag = sqrt(Ix.^2 + Iy.^2);
figure, imshow(gradmag,[]), title(<span class="string">'Gradient magnitude (gradmag)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_02.png" alt=""> <p>勾配振幅で watershed 変換を直接使用することにより、イメージを分割できますか?</p><pre class="codeinput">L = watershed(gradmag);
Lrgb = label2rgb(L);
figure, imshow(Lrgb), title(<span class="string">'Watershed transform of gradient magnitude (Lrgb)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_03.png" alt=""> <p>いいえ。下記のマーカー計算などの追加の事前処理なしでは、watershed 変換を直接使用すると、結果は &quot;oversegmentation&quot; となります。</p><h2>手順 3: 前景オブジェクトのマーク付け<a name="5"></a></h2><p>さまざまな手順をここに適用して前景のマーカーを検出します。これは各前景オブジェクト内のピクセルの連結された粒子でなければなりません。この例では、&quot;opening-by-reconstruction&quot; および &quot;closing-by-reconstruction&quot; と呼ばれるモルフォロジー手法を使用して、イメージを &quot;消去&quot; します。これらの操作は、<tt>imregionalmax</tt> を使用して配置できる各オブジェクト内のフラット最大値を作成します。</p><p>オープン処理は、縮退の後に膨張を行ないます。opening-by-reconstruction は縮退の後にモルフォロジー再構成を行います。この 2 つを比較します。まず、<tt>imopen</tt> を使用してオープン処理を計算します。</p><pre class="codeinput">se = strel(<span class="string">'disk'</span>, 20);
Io = imopen(I, se);
figure, imshow(Io), title(<span class="string">'Opening (Io)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_04.png" alt=""> <p>次に <tt>imerode</tt> および <tt>imreconstruct</tt> を使用して opening-by-reconstruction を計算します。</p><pre class="codeinput">Ie = imerode(I, se);
Iobr = imreconstruct(Ie, I);
figure, imshow(Iobr), title(<span class="string">'Opening-by-reconstruction (Iobr)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_05.png" alt=""> <p>オープン処理の後でクローズ処理をすると、暗斑およびステム マークを削除できます。通常のモルフォロジー クローズ処理と closing-by-reconstruction を比較します。最初に <tt>imclose</tt> を試行します。</p><pre class="codeinput">Ioc = imclose(Io, se);
figure, imshow(Ioc), title(<span class="string">'Opening-closing (Ioc)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_06.png" alt=""> <p>そして、<tt>imdilate</tt> を使用し、その後 <tt>imreconstruct</tt> を使用します。<tt>imreconstruct</tt> のイメージ入力と出力を補足しなければならないことに注意してください。</p><pre class="codeinput">Iobrd = imdilate(Iobr, se);
Iobrcbr = imreconstruct(imcomplement(Iobrd), imcomplement(Iobr));
Iobrcbr = imcomplement(Iobrcbr);
figure, imshow(Iobrcbr), title(<span class="string">'Opening-closing by reconstruction (Iobrcbr)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_07.png" alt=""> <p><tt>Iobrcbr</tt> と <tt>Ioc</tt> を比較すると、オブジェクトの全体の形状に影響を与えずに小さな傷を削除する際、再構成ベースのオープン処理およびクローズ処理が標準のオープン処理およびクローズ処理よりも効率的であることがわかります。<tt>Iobrcbr</tt> の局所的最大値を計算して、適切な前景のマーカーを取得します。</p><pre class="codeinput">fgm = imregionalmax(Iobrcbr);
figure, imshow(fgm), title(<span class="string">'Regional maxima of opening-closing by reconstruction (fgm)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_08.png" alt=""> <p>結果を解釈するには、前景マーカー イメージを元のイメージに重ね合わせます。</p><pre class="codeinput">I2 = I;
I2(fgm) = 255;
figure, imshow(I2), title(<span class="string">'Regional maxima superimposed on original image (I2)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_09.png" alt=""> <p>最も遮蔽され影になったオブジェクトのいくつかはマークされていません。これらのオブジェクトが、最終結果で適切に分割されないということです。また、オブジェクトの前景マーカーがオブジェクトのエッジにまで到達しています。マーカー粒子のエッジをきれいにし、縮小する必要があります。クローズ処理の後の縮退処理によって、実行できます。</p><pre class="codeinput">se2 = strel(ones(5,5));
fgm2 = imclose(fgm, se2);
fgm3 = imerode(fgm2, se2);
</pre><p>この手順は、削除されなければならない散在して孤立したピクセルを残す可能性があります。関数 <tt>bwareaopen</tt> を使用することにより、一定数のピクセルより少ないすべての粒子を削除できます。</p><pre class="codeinput">fgm4 = bwareaopen(fgm3, 20);
I3 = I;
I3(fgm4) = 255;
figure, imshow(I3)
title(<span class="string">'Modified regional maxima superimposed on original image (fgm4)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_10.png" alt=""> <h2>手順 4: 背景マーカーの計算<a name="14"></a></h2><p>ここで、背景にマークを付ける必要があります。クリーンアップされたイメージ <tt>Iobrcbr</tt> では、暗い色のピクセルは背景に属するため、しきい値処理から開始できます。</p><pre class="codeinput">bw = im2bw(Iobrcbr, graythresh(Iobrcbr));
figure, imshow(bw), title(<span class="string">'Thresholded opening-closing by reconstruction (bw)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_11.png" alt=""> <p>背景ピクセルは黒色ですが、背景マーカーが分割するオブジェクトのエッジに近すぎないことが理想です。<tt>bw</tt> の前景の &quot;skeleton by influence zones&quot; すなわち SKIZ を計算することにより、背景を &quot;希薄&quot; にします。これは、<tt>bw</tt> の距離変換の watershed 変換を計算し、結果の流域の稜線 (<tt>DL == 0</tt>) を探すことにより、実行できます。 </p><pre class="codeinput">D = bwdist(bw);
DL = watershed(D);
bgm = DL == 0;
figure, imshow(bgm), title(<span class="string">'Watershed ridge lines (bgm)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_12.png" alt=""> <h2>手順 5: セグメント化関数の Watershed 変換の計算<a name="16"></a></h2><p>関数 <tt>imimposemin</tt> は、イメージが特定の場所にのみ局所的最小値をもつように、イメージを変更するために使用できます。ここで、関数 <tt>imimposemin</tt> を使用して、局所的最小値のみが前景と背景マーカー ピクセルで発生するように、勾配振幅イメージを変更します。</p><pre class="codeinput">gradmag2 = imimposemin(gradmag, bgm | fgm4);
</pre><p>これで、watershed ベースのセグメント化を計算する準備ができました。</p><pre class="codeinput">L = watershed(gradmag2);
</pre><h2>手順 6: 結果の可視化<a name="18"></a></h2><p>可視化の手法の 1 つは、前景マーカー、背景マーカー、および分割されたオブジェクトの境界線を元のイメージに重ね合わせる手法です。必要に応じて膨張を使用し、オブジェクトの境界など特定の局面をより明確にします。オブジェクトの境界線は <tt>L == 0</tt> にあります。</p><pre class="codeinput">I4 = I;
I4(imdilate(L == 0, ones(3, 3)) | bgm | fgm4) = 255;
figure, imshow(I4)
title(<span class="string">'Markers and object boundaries superimposed on original image (I4)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_13.png" alt=""> <p>この可視化は、前景および背景マーカーの場所が結果に与える影響を示します。いくつかの場所では、遮蔽されたオブジェクトは前景マーカーをもたないため、部分的に遮蔽された暗い色のオブジェクトは、隣接する明るい色のオブジェクトにマージされます。</p><p>別の便利な可視化の手法は、ラベル行列をカラー イメージとして表示することです。<tt>watershed</tt> および <tt>bwlabel</tt> で作成されたようなラベル行列は、<tt>label2rgb</tt> を使用して、可視化目的のためにトゥルーカラー イメージに変換できます。</p><pre class="codeinput">Lrgb = label2rgb(L, <span class="string">'jet'</span>, <span class="string">'w'</span>, <span class="string">'shuffle'</span>);
figure, imshow(Lrgb)
title(<span class="string">'Colored watershed label matrix (Lrgb)'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_14.png" alt=""> <p>透明性を使用して、この疑似色ラベル行列を元の強度イメージに重ね合わせることができます。</p><pre class="codeinput">figure, imshow(I), hold <span class="string">on</span>
himage = imshow(Lrgb);
set(himage, <span class="string">'AlphaData'</span>, 0.3);
title(<span class="string">'Lrgb superimposed transparently on original image'</span>)
</pre><img vspace="5" hspace="5" src="../ipexwatershed_15.png" alt=""> <p class="footer">Copyright 1993-2008 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.13</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Marker-Controlled Watershed Segmentation % Separating touching objects in an image is one of the more difficult % image processing operations.  The watershed transform is often applied to % this problem.  The watershed transform finds "catchment basins" and % "watershed ridge lines" in an image by treating it as a surface where % light pixels are high and dark pixels are low. % % Segmentation using the watershed transform works better if you can % identify, or "mark," foreground objects and background locations. % Marker-controlled watershed segmentation follows this basic procedure: % % 1. Compute a segmentation function.  This is an image whose dark % regions are the objects you are trying to segment. % % 2. Compute foreground markers.  These are connected blobs of pixels % within each of the objects. % % 3. Compute background markers.  These are pixels that are not part of % any object. % % 4. Modify the segmentation function so that it only has minima at the % foreground and background marker locations. %  % 5. Compute the watershed transform of the modified segmentation function. % % This example highlights many different Image Processing Toolbox(TM) % functions, including |fspecial|, |imfilter|, |watershed|, |label2rgb|, % |imopen|, |imclose|, |imreconstruct|, |imcomplement|, |imregionalmax|, % |bwareaopen|, |graythresh|, and |imimposemin|.  % Copyright 1993-2008 The MathWorks, Inc. % $Revision: 1.1.8.5 $  $Date: 2012/02/14 03:31:42 $  %% Step 1: Read in the Color Image and Convert it to Grayscale  rgb = imread('pears.png'); I = rgb2gray(rgb); imshow(I)  text(732,501,'Image courtesy of Corel(R)',...      'FontSize',7,'HorizontalAlignment','right')  %% Step 2: Use the Gradient Magnitude as the Segmentation Function % Use the Sobel edge masks, |imfilter|, and some simple arithmetic to % compute the gradient magnitude.  The gradient is high at the borders of % the objects and low (mostly) inside the objects.  hy = fspecial('sobel'); hx = hy'; Iy = imfilter(double(I), hy, 'replicate'); Ix = imfilter(double(I), hx, 'replicate'); gradmag = sqrt(Ix.^2 + Iy.^2); figure, imshow(gradmag,[]), title('Gradient magnitude (gradmag)')  %%  % Can you segment the image by using the watershed transform directly on % the gradient magnitude?  L = watershed(gradmag); Lrgb = label2rgb(L); figure, imshow(Lrgb), title('Watershed transform of gradient magnitude (Lrgb)')  %% % No.  Without additional preprocessing such as the marker computations below, % using the watershed transform directly often results in % "oversegmentation."  %% Step 3: Mark the Foreground Objects % A variety of procedures could be applied here to find the foreground % markers, which must be connected blobs of pixels inside each of the % foreground objects.  In this example you'll use morphological % techniques called "opening-by-reconstruction" and % "closing-by-reconstruction" to "clean" up the image.  These % operations will create flat maxima inside each object that can be % located using |imregionalmax|.  %% % Opening is an erosion followed by a dilation, while % opening-by-reconstruction is an erosion followed by a morphological % reconstruction.  Let's compare the two.  First, compute the opening using % |imopen|.  se = strel('disk', 20); Io = imopen(I, se); figure, imshow(Io), title('Opening (Io)')  %% % Next compute the opening-by-reconstruction using |imerode| and % |imreconstruct|.  Ie = imerode(I, se); Iobr = imreconstruct(Ie, I); figure, imshow(Iobr), title('Opening-by-reconstruction (Iobr)')  %% % Following the opening with a closing can remove the dark spots % and stem marks.  Compare a regular morphological closing with a % closing-by-reconstruction.  First try |imclose|:  Ioc = imclose(Io, se); figure, imshow(Ioc), title('Opening-closing (Ioc)')  %% % Now use |imdilate| followed by |imreconstruct|.  Notice you must  % complement the image inputs and output of |imreconstruct|.  Iobrd = imdilate(Iobr, se); Iobrcbr = imreconstruct(imcomplement(Iobrd), imcomplement(Iobr)); Iobrcbr = imcomplement(Iobrcbr); figure, imshow(Iobrcbr), title('Opening-closing by reconstruction (Iobrcbr)')  %% % As you can see by comparing |Iobrcbr| with |Ioc|, reconstruction-based % opening and closing are more  % effective than standard opening and closing at removing small blemishes % without affecting the overall shapes of the objects.  Calculate the % regional maxima of |Iobrcbr| to obtain good foreground markers.  fgm = imregionalmax(Iobrcbr); figure, imshow(fgm), title('Regional maxima of opening-closing by reconstruction (fgm)')  %% % To help interpret the result, superimpose the foreground marker image % on the original image.   I2 = I; I2(fgm) = 255; figure, imshow(I2), title('Regional maxima superimposed on original image (I2)')  %% % Notice that some of the mostly-occluded and shadowed objects are not % marked, which means that these objects will not be segmented properly % in the end result.  Also, the foreground markers in some objects go right % up to the objects' edge.  That means you should clean the edges of the % marker blobs and then shrink them a bit.  You can do this by a closing % followed by an erosion.  se2 = strel(ones(5,5)); fgm2 = imclose(fgm, se2); fgm3 = imerode(fgm2, se2);  %% % This procedure tends to leave some stray isolated pixels that must be % removed.  You can do this using |bwareaopen|, which removes all blobs % that have fewer than a certain number of pixels.   fgm4 = bwareaopen(fgm3, 20); I3 = I; I3(fgm4) = 255; figure, imshow(I3) title('Modified regional maxima superimposed on original image (fgm4)')  %% Step 4: Compute Background Markers % Now you need to mark the background.  In the cleaned-up image, |Iobrcbr|, % the dark pixels belong to the background, so you could start with a % thresholding operation.  bw = im2bw(Iobrcbr, graythresh(Iobrcbr)); figure, imshow(bw), title('Thresholded opening-closing by reconstruction (bw)')  %% % The background pixels are in black, but ideally we don't want the % background markers to be too close to the edges of the objects we are % trying to segment.  We'll "thin" the background by computing the % "skeleton by influence zones", or SKIZ, of the foreground of |bw|. % This can be done by computing the watershed transform of the distance % transform of |bw|, and then looking for the watershed ridge lines (|DL == % 0|) of the result.  D = bwdist(bw); DL = watershed(D); bgm = DL == 0; figure, imshow(bgm), title('Watershed ridge lines (bgm)')  %% Step 5: Compute the Watershed Transform of the Segmentation Function. % The function |imimposemin| can be used to modify an image so that it has  % regional minima only in certain desired locations.  Here you can use % |imimposemin| to modify the gradient magnitude image so that its only % regional minima occur at foreground and background marker pixels.  gradmag2 = imimposemin(gradmag, bgm | fgm4);  %% % Finally we are ready to compute the watershed-based segmentation.  L = watershed(gradmag2);  %% Step 6: Visualize the Result % One visualization technique is to superimpose the foreground % markers, background markers, and segmented object boundaries on the % original image.  You can use dilation as needed to make certain aspects, % such as the object boundaries, more visible.  Object boundaries are % located where |L == 0|.  I4 = I; I4(imdilate(L == 0, ones(3, 3)) | bgm | fgm4) = 255; figure, imshow(I4) title('Markers and object boundaries superimposed on original image (I4)')  %% % This visualization illustrates how the locations of the foreground and % background markers affect the result.  In a couple of locations, % partially occluded darker objects were merged with their brighter % neighbor objects because the occluded objects did not have foreground % markers. % % Another useful visualization technique is to display the label matrix % as a color image.  Label matrices, such as those produced by % |watershed| and |bwlabel|, can be converted to truecolor images for % visualization purposes by using |label2rgb|.  Lrgb = label2rgb(L, 'jet', 'w', 'shuffle'); figure, imshow(Lrgb) title('Colored watershed label matrix (Lrgb)')  %% % You can use transparency to superimpose this pseudo-color label matrix on % top of the original intensity image.  figure, imshow(I), hold on himage = imshow(Lrgb); set(himage, 'AlphaData', 0.3); title('Lrgb superimposed transparently on original image')   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>